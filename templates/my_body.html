{% extends "base.html" %}
{% block main %}
  <div class="digital-twin-page">
    <div class="digital-twin-header">
      <h1>My Body</h1>
      <p class="subtitle">Medical Imaging Viewer</p>
    </div>
    
    <div class="digital-twin-content">
      <div class="medical-viewer-container">
        <!-- Control Panel -->
        <div class="viewer-controls">
          <div class="control-group">
            <label>Window Center:</label>
            <input type="range" id="windowCenterSlider" min="-1000" max="1000" value="0" class="slider">
            <span id="windowCenterValue">0</span>
          </div>
          
          <div class="control-group">
            <label>Window Width:</label>
            <input type="range" id="windowWidthSlider" min="50" max="2000" value="400" class="slider">
            <span id="windowWidthValue">400</span>
          </div>
          
          <div class="control-group">
            <label>Segmentation Opacity:</label>
            <input type="range" id="opacitySlider" min="0" max="100" value="50" class="slider">
            <span id="opacityValue">50%</span>
          </div>
          
          <div class="control-group">
            <label>
              <input type="checkbox" id="showCT" checked>
              Show CT
            </label>
          </div>
          
          <div class="control-group">
            <label>
              <input type="checkbox" id="showSegmentation" checked>
              Show Segmentation
            </label>
          </div>
        </div>
        
        <!-- Image Viewer -->
        <div class="image-viewer">
          <!-- Multi-view Display -->
          <div class="multi-view-container">
            <div class="view-grid">
              <!-- Coronal View (Y) -->
              <div class="view-panel">
                <h4>Coronal (Y)</h4>
                <div class="viewer-canvas-container">
                  <canvas id="coronalCanvas"></canvas>
                </div>
                <div class="control-group">
                  <label>Slice:</label>
                  <input type="range" id="coronalSliceSlider" min="0" max="100" value="50" class="slider">
                  <span id="coronalSliceValue">0</span>
                </div>
              </div>
              
              <!-- Sagittal View (X) -->
              <div class="view-panel">
                <h4>Sagittal (X)</h4>
                <div class="viewer-canvas-container">
                  <canvas id="sagittalCanvas"></canvas>
                </div>
                <div class="control-group">
                  <label>Slice:</label>
                  <input type="range" id="sagittalSliceSlider" min="0" max="100" value="50" class="slider">
                  <span id="sagittalSliceValue">0</span>
                </div>
              </div>
              
            </div>
          </div>
          
        </div>
        
        <!-- Health Information Sidebar -->
        <div class="health-info-sidebar" id="healthInfoSidebar">
          <div class="sidebar-header">
            <h3 id="sidebarTitle">Organ Information</h3>
            <button id="closeSidebar" class="close-btn">×</button>
          </div>
          <div class="sidebar-content" id="sidebarContent">
            <p class="sidebar-placeholder">Click on an organ in the medical images to view health information.</p>
          </div>
        </div>
        
      </div>
    </div>
  </div>
{% endblock %}

{% block input %}
  <!-- Input box fixed at bottom -->
  <div class="input-container fixed">
    <div class="input-wrapper">
      <button id="micButton" class="mic-button" type="button" title="Voice input">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z" fill="currentColor"/>
          <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z" fill="currentColor"/>
        </svg>
      </button>
      <textarea 
        id="messageInput" 
        class="message-input" 
        placeholder="Ask anything" 
        rows="1"
        maxlength="2000"
      ></textarea>
      <button id="sendButton" class="send-button" type="button">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z" fill="currentColor"/>
        </svg>
      </button>
    </div>
    <div class="disclaimer">
      <span>Disclaimer</span>
    </div>
  </div>
{% endblock %}

{% block scripts %}
  <script>
    class MedicalImageViewer {
      constructor() {
        // Initialize multiple canvases
        this.coronalCanvas = document.getElementById('coronalCanvas');
        this.coronalCtx = this.coronalCanvas.getContext('2d');
        this.sagittalCanvas = document.getElementById('sagittalCanvas');
        this.sagittalCtx = this.sagittalCanvas.getContext('2d');
        
        this.metadata = null;
        this.currentView = 'coronal';
        this.currentSlice = { x: 0, y: 0, z: 0 };
        this.windowCenter = 0;
        this.windowWidth = 400;
        this.segmentationOpacity = 0.5;
        this.showCT = true;
        this.showSegmentation = true;
        this.organStats = {};
        
        // Debouncing for performance optimization
        this.loadDebounceTimer = null;
        this.debounceDelay = 150; // ms
        
        this.initializeControls();
        this.initializeSidebar();
        this.loadMetadata();
      }
      
      initializeControls() {
        // Debounced load function for better performance
        const debouncedLoad = () => {
          if (this.loadDebounceTimer) {
            clearTimeout(this.loadDebounceTimer);
          }
          this.loadDebounceTimer = setTimeout(() => {
            this.loadAllViews();
          }, this.debounceDelay);
        };
        
        // Individual axis slice sliders
        document.getElementById('coronalSliceSlider').addEventListener('input', (e) => {
          const sliceValue = parseInt(e.target.value);
          this.currentSlice.y = sliceValue;
          document.getElementById('coronalSliceValue').textContent = sliceValue;
          this.loadView({ axis: 'y', slice: sliceValue, canvas: this.coronalCanvas, ctx: this.coronalCtx, label: 'coronalSliceValue' });
        });
        
        document.getElementById('sagittalSliceSlider').addEventListener('input', (e) => {
          const sliceValue = parseInt(e.target.value);
          this.currentSlice.x = sliceValue;
          document.getElementById('sagittalSliceValue').textContent = sliceValue;
          this.loadView({ axis: 'x', slice: sliceValue, canvas: this.sagittalCanvas, ctx: this.sagittalCtx, label: 'sagittalSliceValue' });
        });
        
        // Window/Level controls
        document.getElementById('windowCenterSlider').addEventListener('input', (e) => {
          this.windowCenter = parseInt(e.target.value);
          document.getElementById('windowCenterValue').textContent = this.windowCenter;
          debouncedLoad();
        });
        
        document.getElementById('windowWidthSlider').addEventListener('input', (e) => {
          this.windowWidth = parseInt(e.target.value);
          document.getElementById('windowWidthValue').textContent = this.windowWidth;
          debouncedLoad();
        });
        
        // Segmentation opacity
        document.getElementById('opacitySlider').addEventListener('input', (e) => {
          this.segmentationOpacity = parseInt(e.target.value) / 100;
          document.getElementById('opacityValue').textContent = Math.round(this.segmentationOpacity * 100) + '%';
          debouncedLoad();
        });
        
        // Show CT toggle
        document.getElementById('showCT').addEventListener('change', (e) => {
          this.showCT = e.target.checked;
          debouncedLoad();
        });
        
        // Show segmentation toggle
        document.getElementById('showSegmentation').addEventListener('change', (e) => {
          this.showSegmentation = e.target.checked;
          debouncedLoad();
        });
        
        // Canvas click events for organ selection
        this.coronalCanvas.addEventListener('click', (e) => {
          this.handleCanvasClick(e, 'y', this.currentSlice.y);
        });
        this.sagittalCanvas.addEventListener('click', (e) => {
          this.handleCanvasClick(e, 'x', this.currentSlice.x);
        });
        
        // Add cursor pointer style to canvases
        this.coronalCanvas.style.cursor = 'pointer';
        this.sagittalCanvas.style.cursor = 'pointer';
      }
      
      initializeSidebar() {
        // Close sidebar button
        document.getElementById('closeSidebar').addEventListener('click', () => {
          document.getElementById('healthInfoSidebar').classList.remove('active');
        });
        
        // Close sidebar on escape key
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') {
            document.getElementById('healthInfoSidebar').classList.remove('active');
          }
        });
      }
      
      async loadMetadata() {
        try {
          const response = await fetch('/api/my-body/metadata');
          const data = await response.json();
          
          if (data.success) {
            this.metadata = data.metadata;
            this.organStats = data.metadata.organ_stats;
            this.updateSliceRange();
            // this.populateOrganList(); // Disabled: Do not load Available Organs on frontend
            this.loadAllViews();
          } else {
            console.error('Failed to load metadata:', data.message);
            this.showError('Failed to load medical imaging data');
          }
        } catch (error) {
          console.error('Error loading metadata:', error);
          this.showError('Error loading medical imaging data');
        }
      }
      
      updateSliceRange() {
        if (!this.metadata) return;
        
        // Update individual axis sliders
        const maxSlicesX = this.metadata.ct_shape[0] - 1;
        const maxSlicesY = this.metadata.ct_shape[1] - 1;
        const maxSlicesZ = this.metadata.ct_shape[2] - 1;
        
        // Coronal (Y) slider
        const coronalSlider = document.getElementById('coronalSliceSlider');
        coronalSlider.max = maxSlicesY;
        coronalSlider.value = this.currentSlice.y || Math.floor(maxSlicesY / 2);
        this.currentSlice.y = parseInt(coronalSlider.value);
        document.getElementById('coronalSliceValue').textContent = this.currentSlice.y;
        
        // Sagittal (X) slider
        const sagittalSlider = document.getElementById('sagittalSliceSlider');
        sagittalSlider.max = maxSlicesX;
        sagittalSlider.value = this.currentSlice.x || Math.floor(maxSlicesX / 2);
        this.currentSlice.x = parseInt(sagittalSlider.value);
        document.getElementById('sagittalSliceValue').textContent = this.currentSlice.x;
      }
      
      async loadAllViews() {
        if (!this.metadata) return;
        
        // Load both orthogonal views simultaneously with optimized loading
        const views = [
          { axis: 'y', slice: this.currentSlice.y || Math.floor(this.metadata.ct_shape[1] / 2), canvas: this.coronalCanvas, ctx: this.coronalCtx, label: 'coronalSliceValue' },
          { axis: 'x', slice: this.currentSlice.x || Math.floor(this.metadata.ct_shape[0] / 2), canvas: this.sagittalCanvas, ctx: this.sagittalCtx, label: 'sagittalSliceValue' }
        ];
        
        // Load all views in parallel with error handling
        const promises = views.map(view => this.loadView(view).catch(error => {
          console.error(`Error loading ${view.axis} view:`, error);
          // Continue with other views even if one fails
          return null;
        }));
        
        await Promise.allSettled(promises);
      }
      
      async loadView(view) {
        try {
          const params = new URLSearchParams({
            axis: view.axis,
            slice: view.slice,
            window_center: this.windowCenter,
            window_width: this.windowWidth,
            show_ct: this.showCT,
            show_segmentation: this.showSegmentation,
            segmentation_opacity: this.segmentationOpacity
          });
          
          const response = await fetch(`/api/my-body/slice?${params}`);
          const data = await response.json();
          
          if (data.success) {
            this.displaySlice(data.data, view.ctx, view.canvas);
            document.getElementById(view.label).textContent = view.slice;
          } else {
            this.showErrorState(view.canvas, view.ctx, 'Failed to load slice');
          }
        } catch (error) {
          console.error(`Error loading ${view.axis} view:`, error);
          this.showErrorState(view.canvas, view.ctx, 'Network error');
        }
      }
      
      
      showErrorState(canvas, ctx, message) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#444';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.fillStyle = '#ff6b6b';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(message, canvas.width / 2, canvas.height / 2);
      }
      
      displaySlice(sliceData, ctx, canvas) {
        // Use requestAnimationFrame for smoother rendering
        const renderFrame = () => {
          // Function to draw segmentation at original size
          const drawSegmentation = (imgWidth, imgHeight) => {
            if (sliceData.segmentation_image && this.showSegmentation) {
              const segImg = new Image();
              segImg.onload = () => {
                ctx.save();
                ctx.globalAlpha = this.segmentationOpacity;
                ctx.drawImage(segImg, 0, 0);
                ctx.restore();
              };
              segImg.src = `data:image/png;base64,${sliceData.segmentation_image}`;
            }
          };
          
          // Draw CT image if available, otherwise just draw segmentation
          if (sliceData.ct_image) {
            const ctImg = new Image();
            ctImg.onload = () => {
              // Resize canvas to match image dimensions
              canvas.width = ctImg.width;
              canvas.height = ctImg.height;
              
              // Draw CT image at original size
              ctx.drawImage(ctImg, 0, 0);
              
              // Draw segmentation overlay at original size
              drawSegmentation(ctImg.width, ctImg.height);
            };
            ctImg.src = `data:image/png;base64,${sliceData.ct_image}`;
          } else if (sliceData.segmentation_image) {
            // No CT, just draw segmentation
            const segImg = new Image();
            segImg.onload = () => {
              // Resize canvas to match image dimensions
              canvas.width = segImg.width;
              canvas.height = segImg.height;
              
              // Fill with black background
              ctx.fillStyle = '#000000';
              ctx.fillRect(0, 0, canvas.width, canvas.height);
              
              // Draw segmentation at original size
              ctx.drawImage(segImg, 0, 0);
            };
            segImg.src = `data:image/png;base64,${sliceData.segmentation_image}`;
          }
        };
        
        // Use requestAnimationFrame for better performance
        requestAnimationFrame(renderFrame);
      }
      
      
      async handleCanvasClick(event, axis, slice) {
        const canvas = event.target;
        const rect = canvas.getBoundingClientRect();
        
        // Get click coordinates relative to canvas
        const clickX = event.clientX - rect.left;
        const clickY = event.clientY - rect.top;
        
        // Convert to image coordinates (account for canvas scaling)
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const imageX = Math.floor(clickX * scaleX);
        const imageY = Math.floor(clickY * scaleY);
        
        try {
          const params = new URLSearchParams({
            axis: axis,
            slice: slice,
            x: imageX,
            y: imageY
          });
          
          const response = await fetch(`/api/my-body/click-organ?${params}`);
          const data = await response.json();
          
          if (data.success && data.organ_name) {
            this.showOrganInfo(data);
          } else if (data.success && !data.organ_name) {
            this.showNoOrganInfo();
          } else {
            console.error('Failed to get organ info:', data.message);
          }
        } catch (error) {
          console.error('Error fetching organ info:', error);
        }
      }
      
      showOrganInfo(organData) {
        const organNameFormatted = organData.organ_name.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        const volumeFormatted = Math.round(organData.volume).toLocaleString();
        const intensityFormatted = organData.intensity.toFixed(1);
        
        // Update sidebar title
        document.getElementById('sidebarTitle').textContent = organNameFormatted;
        
        // Build health information HTML if available
        let healthInfoHTML = '';
        if (organData.health_info && Object.keys(organData.health_info).length > 0) {
          const healthInfo = organData.health_info;
          
          healthInfoHTML = `
            <div class="health-info-section">
              <h4>Health Information</h4>
              
              ${healthInfo.description ? `
                <div class="organ-description">
                  ${healthInfo.description}
                </div>
              ` : ''}
              
              ${healthInfo.health_info ? `
                ${healthInfo.health_info.common_conditions ? `
                  <div class="info-category">
                    <strong class="health-conditions">Common Conditions:</strong>
                    <ul>
                      ${healthInfo.health_info.common_conditions.map(condition => `<li>${condition}</li>`).join('')}
                    </ul>
                  </div>
                ` : ''}
                
                ${healthInfo.health_info.symptoms_to_watch ? `
                  <div class="info-category">
                    <strong class="health-symptoms">Symptoms to Watch:</strong>
                    <ul>
                      ${healthInfo.health_info.symptoms_to_watch.map(symptom => `<li>${symptom}</li>`).join('')}
                    </ul>
                  </div>
                ` : ''}
                
                ${healthInfo.health_info.preventive_measures ? `
                  <div class="info-category">
                    <strong class="health-prevention">Preventive Measures:</strong>
                    <ul>
                      ${healthInfo.health_info.preventive_measures.map(measure => `<li>${measure}</li>`).join('')}
                    </ul>
                  </div>
                ` : ''}
                
                ${healthInfo.health_info.screening_recommendations ? `
                  <div class="info-category">
                    <strong class="health-screening">Screening Recommendations:</strong>
                    <ul>
                      ${healthInfo.health_info.screening_recommendations.map(screening => `<li>${screening}</li>`).join('')}
                    </ul>
                  </div>
                ` : ''}
                
                ${healthInfo.normal_values ? `
                  <div class="info-category">
                    <strong class="health-normal">Normal Values:</strong>
                    <div class="normal-values">
                      ${Object.entries(healthInfo.normal_values).map(([key, value]) => 
                        `<div><strong>${key.replace(/_/g, ' ')}:</strong> ${value}</div>`
                      ).join('')}
                    </div>
                  </div>
                ` : ''}
              ` : ''}
            </div>
          `;
        }
        
        // Update sidebar content
        document.getElementById('sidebarContent').innerHTML = `
          <div class="organ-stats">
            <div class="stat-item">
              <strong>Volume:</strong> ${volumeFormatted} mm³
            </div>
            <div class="stat-item">
              <strong>Intensity:</strong> ${intensityFormatted} HU
            </div>
          </div>
          
          ${healthInfoHTML}
        `;
        
        // Show sidebar
        document.getElementById('healthInfoSidebar').classList.add('active');
      }
      
      showNoOrganInfo() {
        // Update sidebar to show no organ message
        document.getElementById('sidebarTitle').textContent = 'No Organ Selected';
        document.getElementById('sidebarContent').innerHTML = `
          <p class="no-organ-message">No organ at this location</p>
          <p class="sidebar-placeholder">Click on an organ in the medical images to view health information.</p>
        `;
        
        // Keep sidebar visible but with no organ info
        document.getElementById('healthInfoSidebar').classList.add('active');
      }
      
      populateOrganList() {
        const organList = document.getElementById('organList');
        organList.innerHTML = '';
        
        Object.entries(this.organStats).forEach(([organName, stats]) => {
          if (stats.volume > 0) { // Only show organs with volume > 0
            const organItem = document.createElement('div');
            organItem.className = 'organ-item';
            organItem.innerHTML = `
              <div class="organ-name">${organName.replace(/_/g, ' ')}</div>
              <div class="organ-stats">
                <span>Volume: ${Math.round(stats.volume).toLocaleString()}</span>
                <span>Intensity: ${stats.intensity.toFixed(1)}</span>
              </div>
            `;
            organItem.addEventListener('click', () => {
              this.showOrganInfo(organName.replace(/_/g, ' '), 
                `Volume: ${Math.round(stats.volume).toLocaleString()}<br>Intensity: ${stats.intensity.toFixed(1)}`);
            });
            organList.appendChild(organItem);
          }
        });
      }
      
      
      showError(message) {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = '#ff6b6b';
        this.ctx.font = '16px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.fillText(message, this.canvas.width / 2, this.canvas.height / 2);
      }
    }
    
    // Initialize the viewer when the page loads
    document.addEventListener('DOMContentLoaded', () => {
      new MedicalImageViewer();
    });
  </script>
{% endblock %}
